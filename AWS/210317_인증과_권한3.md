# 인증과 권한

### 사용자 정의 권한 모듈 > API Gateway 권한 부여자를 이용한 권한 부여

API Gateway의 **권한 부여자**를 이용해서 JWT 토큰을 검증하여 유효한 토큰인 경우에만 프로필을 조회하는 람다 함수를 실행할 수 있는 권한 부여<br>
참고 : https://auth0.com/docs/tokens/json-web-tokens/validate-json-web-tokens

![image](https://user-images.githubusercontent.com/77096463/111397809-87ed6380-8705-11eb-9d2e-1fa1e0c7c04c.png)

<br>

**JWT 토큰 검증하는 custom-authorizer 람다 함수 생성**

람다 함수 생성<br>
- 이름 : custom-authorizer
- 런타임 : Node.js 12.x
- 실행 역할 : 기존 역할 사용 > api-gateway-lambda-exec-role

![image](https://user-images.githubusercontent.com/77096463/111398356-abfd7480-8706-11eb-851e-ad28b5cef958.png)

<br>

작업 디렉터리 생성 및 필요 모듈 설치<br>
- `jsonwebtoken` : 토큰의 무결성 확인하고 디코딩 하는데 도움

```
PS C:\Users\Lenovo> cd C:\serverless\
PS C:\serverless> mkdir custom-authorizer
PS C:\serverless> cd .\custom-authorizer\

PS C:\serverless\custom-authorizer> npm init -y

PS C:\serverless\custom-authorizer> npm install jsonwebtoken
```

<br>

package.json 파일의 predeploy, deploy 스크립트 추가

```json
//C:\serverless\custom-authorizer\package.json
{
  "name": "custom-authorizer",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "predeploy": "del Lambda-Deployment.zip & zip -r Lambda-Deployment.zip * -x *.zip *.log node_modules/aws-sdk/*", 
    "deploy": "aws lambda update-function-code --function-name arn:aws:lambda:us-east-1:256193732381:function:custom-authorizer --zip-file fileb://Lambda-Deployment.zip"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "jsonwebtoken": "^8.5.1"
  }
}
```

<br>

람다 함수 구현 > index.js 파일 생성한 후 코드 작성

```js
//C:\serverless\custom-authorizer\index.js
'use strict';

var jwt = require('jsonwebtoken');

//generatePolicy 함수를 정의
/* 정책 문서 형식 버전
{
    "principalId": "user",
    "policyDocument": {
        "Version": "2012-10-17",
        "Statement": [
        {
            "Action": "execute-api:Invoke",
            "Effect": "Deny",
            "Resource": "*"
        }
        ]
    }
} 
*/
var generatePolicy = function(principalId, effect, resource){
    var authResponse = {};  //객체 선언
    authResponse.principalId = principalId;
    if(effect&&resource){
        var policyDocument = {};
        policyDocument.Version = '2012-10-17';  //정책 문서 형식 버전
        policyDocument.Statement = [];  //배열 선언
        
        var statementOne = {};
        statementOne.Action = 'execute-api:Invoke';
        statementOne.Effect = effect;
        statementOne.Resource = resource;

        policyDocument.Statement[0] = statementOne;
        authResponse.policyDocument = policyDocument;
    }
    return authResponse;
};

//핸들러 함수 정의
exports.handler = function(event, context, callback){
    if(!event.authroizationToken){
        callback('Could not find authroizationToken');
        return;
    }

    //JWT 토큰의 앞부분(Bearer) 제거
    var token = event.authroizationToken.split(' ')[1];
    
    //auth0.com에서 제공한 Client secret을 환경변수로부터 읽어와 변수에 할당
    var secretBuffer = new Buffer(process.env.AUTH0_SECRET);
    jwt.verify(token, secretBuffer, function(err,decoded){
        if(err){
            console.log('Failed jwt verification: ', err, 'auth: ', event.authroizationToken);
            callback('Authorization failed');
        }else{
            var policy = generatePolicy('user','allow', event.methodArn);
            console.log(policy);
            callback(null, policy);
        }
    })
}
```

<br>

람다 함수 배포

```
PS C:\serverless\custom-authorizer> npm run deploy
```

![image](https://user-images.githubusercontent.com/77096463/111400372-8d00e180-870a-11eb-81b9-80530e2a23fb.png)

<br>

람다 함수 실행에 필요한 환경 변수(AUTH0_SECRET) 등록 > auth0.com의 Client Secret 값 입력

![image](https://user-images.githubusercontent.com/77096463/111400513-d2bdaa00-870a-11eb-90e4-bad47d12a15c.png)

<br>

**람다 함수 테스트**

(1) 로컬 스토리지에 저장된 idToken 값에 "Bearer"를 추가한 값을 "authroizationToken" 값으로 설정

![image](https://user-images.githubusercontent.com/77096463/111400716-3cd64f00-870b-11eb-9514-1d9beea5064b.png)

<br>

```
{
	"authroizationToken" : "Bearer xxxxxxxxxxxxxxxxxxxxx..."
}
```

<br>

(2) 람다 함수> 테스트 이벤트에 authroizationToken 값 넣어주기

![image](https://user-images.githubusercontent.com/77096463/111400909-9cccf580-870b-11eb-9e8d-4cc32206453d.png)

<br>

변경 사항 저장 후 테스트 이벤트를 호출하면  'Authorization failed' 에러가 나는데 현재 에러가 날 수 밖에 없다.

![image](https://user-images.githubusercontent.com/77096463/111402827-3f3aa800-870f-11eb-9881-65d0ac919e59.png)

<br>

(3) JWT 토큰 수작업으로 검증 > http://jwt.io 사이트 참고

- signature verified로 JWT 토큰 자체에는 문제가 없는 걸로 나옴 
- 따라서, 알고리즘을 수정할 예정

![image](https://user-images.githubusercontent.com/77096463/111402990-8c1e7e80-870f-11eb-9661-79f028ef0988.png)

<br>

(4) auth0.com 으로 이동하여 서명에서 사용하는 알고리즘 변경

- Applications > 24-Hour Video > Show Advanced Settings > OAuth 탭
- OIDC Conformat을 해제한 후 JWT Signature Algorithm을 HS246으로 변경

![image](https://user-images.githubusercontent.com/77096463/111403149-e0c1f980-870f-11eb-9ae8-dec325587dd1.png)

<br>

Specify the algorithm used to sign the JsonWebToken: 

- **HS256**: JWT will be signed with your client secret. ⇐ 비밀키 암호화 방식
- **RS256**: JWT will be signed with your private signing key and they can be verified using your public signing key. ⇐ 공개키 암호화 방식 

<br>

(5) 재로그인하여 재발급받은 idToken을 테스트 이벤트에 넣어주기 > 이후 변경사항을 저장하고 호출하면 실행 결과가 '성공'으로 출력됨

![image](https://user-images.githubusercontent.com/77096463/111403362-2f6f9380-8710-11eb-9eee-1a9406017f72.png) 

<br>

(JWT 상세 정보 참고 : http://velopert.com/2389)

<br>

API Gateway에 **권한 부여자** 생성

- API Gateway > 24-Hour Video API > 권한 부여자 생성
- 이름 : custom-authorizer
- 유형 : Lambda
- Lambda 함수 : us-east-1 > custom-authorizer
- 토큰 원본 : method.request.header.Authorization

![image](https://user-images.githubusercontent.com/77096463/111404270-cee15600-8711-11eb-902c-a02398625c6e.png)

<br> Authorization의 header의 값을 통해 토큰을 검증 > 이 때 호출하는 함수는 custom-authorizer 람다 함수

사용자 정의 권한 부여자를 /user-profile - GET 메서드에 연결<br>
주의 : API Gateway 대시보드를 이동했다가 다시 리소스 메뉴로 이동 (AWS 버그때문에)

![image](https://user-images.githubusercontent.com/77096463/111404735-aa39ae00-8712-11eb-8828-fd43f2e513d0.png)

<br>

작업을 완료한 후, API 배포하기 (작업 단계로 dev 선택)<br>
로그인 후 프로필 버튼을 클릭했을 때 사용자 정보가 콘솔에 출력되는지 확인 (<u>에러</u>)<br>
개발자 도구를 이용해서 idToken 값을 수정(조작)했을 때 오류가 출력되는 것을 확인








