# 스토리지

### S3 부가 기능

**버전 관리**<br>
- 객체를 덮어 쓴 경우, 이전 버전으로 돌아갈 수 있음
- 버전 관리 기능은 활성화해서 사용
- 버전 관리를 해제할 수 없음 (단, 중지는 가능)

**정적 웹 사이트 호스팅**<br>
- 서버 측 코드 실행은 지원하지 않음
- HTML, CSS, Image, JavaScript와 같은 정적인 컨텐츠 제공 (서비스)

**스토리지 클래스**<br>
- 중복성, 액세스 특징 및 가격 정책에 따라 4가지 스토리지 클래스를 지원
- 요금 : 저장 비용(스토리지 클래스, 리전, 저장된 데이터의 양)과 요청 비용(요청과 데이터 전송)으로 구분
	- Standard
	 	- 오브젝트 생성할 때 기본 설정
	 	- 데이터에 자주 액세스할 때 적합
	 	- 99.999999999% 내구성 지원
	 	- 저장 비용 -> 10,000건의 요청당 $0.004
	 	- 사용 비용 -> 처음 1TB의 데이터/월 사용 시 GB당 $0.0300 
	- Standard_IA(Infrequent Access)
		- 자주 액세스하지 않는 데이터에 적합
	- Glacier
		- 간헐적으로 접근할 때 적합
		- 데이터를 가져오는 데 3~5시간 소요
		- 처음부터 Glacier 클래스로 객체 생성 불가 -> 생명주기 관리 규칙을 사용해서 Glacier로 전환
	- Reduced Redundancy
		- 99.99% 내구성 지원 -> 데이터 유실이 발생할 수 있음

<br>

---------------

### 웹 페이지를 통해 인증된 사용자만 S3 버킷에 파일을 업로드할 수 있도록 제한

![image](https://user-images.githubusercontent.com/77096463/111719690-b99a3200-889f-11eb-8965-0372bef1d061.png)

<br>

람다 함수 -> 사용자를 확인하고 S3에 파일을 업로드하는데 필요한 정책과 서명을 생성

<br>

### 1. upload-s3 사용자 생성 및 업로드 정책 생성

IAM 사용자 생성

- 이름 : upload-s3
- 액세스 유형 : 프로그래밍 방식 액세스
- 권한 설정 -> 정책 생성 (s3버킷에 객체 목록을 가져오고 객체 업로드를 허용하는 정책) 

```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Resource" : "arn:aws:s3:::serverless-video-upload-haerim",	<-업로드 버킷
            "Action" : "s3:ListBucket",
            "Effect" : "Allow"
        },
        {
            "Resource" : "arn:aws:s3:::serverless-video-upload-haerim/*",
            "Action" : "s3:PutObject",
            "Effect" : "Allow"
        }
    ]
}
```

<br>

이후 upload-policy 이름으로 정책을 생성한 후 사용자 권한으로 방금 생성한 정책을 지정

![image](https://user-images.githubusercontent.com/77096463/111720311-f581c700-88a0-11eb-868a-0a88ad7c3b05.png)

<br>

사용자 생성 후 액세스키 ID와 비밀 액세스 키 csv 파일을 잘 보관한다.

![image](https://user-images.githubusercontent.com/77096463/111720379-1518ef80-88a1-11eb-97ce-01f9f1dc1a91.png)

<br>

<br>

### 2. 람다 함수 생성 및 배포

작업 디렉토리 생성

```
PS C:\Users\Lenovo> cd C:\serverless\
PS C:\serverless> mkdir get-upload-policy
PS C:\serverless> cd .\get-upload-policy\

PS C:\serverless\get-upload-policy> npm init -y
```

<br>

모듈 설치

```
PS C:\serverless\get-upload-policy> npm install -y async
PS C:\serverless\get-upload-policy> npm install -y crypto-js
```

<br>

package.json 파일에 create, precreate 스크립트 저장

```json
// C:\serverless\get-upload-policy\package.json
{
  "name": "get-upload-policy",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "create": "aws lambda create-function --function-name get-upload-policy --handler index.handler --memory-size 128 --runtime nodejs12.x --role arn:aws:iam::256193732381:role/lambda-s3-execution-role --timeout 3 --publish --zip-file fileb://Lambda-Deployment.zip",
    "precreate": "zip -r Lambda-Deployment.zip * -x *.zip *.log node_modules/aws-sdk/*"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "async": "^3.2.0",
    "crypto-js": "^4.0.0"
  }
}
```

<br>

람다 함수 작성

```js
//index.js
// P242
'use strict';
 
var async = require('async');
var crypto = require("crypto-js");
 
// 상수를 정의 
const C_ACL = 'private';    
const C_NOW = new Date().toISOString();                     // 현재 시간 2021-03-19T02:04:38.030Z
const C_DATE_STAMP = C_NOW.slice(0,10).replace(/-/g,'');    // 현재 시간을 YYYYMMDD 형식으로 변환 2021-03-19 => 20210319
const C_REGION_NAME = 'us-east-1';  
const C_SERVICE_NAME = 's3';
const C_X_AMZ_DATE = C_NOW.replace(/[-:\.]/g,'');           // 20210319T020438030Z
const C_X_AMZ_ALGORITHM = 'AWS4-HMAC-SHA256';
const C_X_AMZ_CREDENTIAL = `${process.env.ACCESS_KEY}/${C_DATE_STAMP}/${C_REGION_NAME}/${C_SERVICE_NAME}/aws4_request`;
 
// 반환할 오류 메시지 포맷을 정의해서 반환하는 함수
function createErrorResponse(errCode, errMessage) {
    var response = {
        'statusCode': errCode, 
        'headers': { 'Access-Control-Allow-Origin': '*' }, 
        'body': JSON.stringify({ 'error': errMessage })
    };
    return response;
}
 
// 반환할 성공 메시지 포맷을 정의해서 반환하는 함수
function createSuccessResponse(message) {
    var response = {
        'statusCode': 200, 
        'headers': { 'Access-Control-Allow-Origin': '*' }, 
        'body': JSON.stringify(message)
    };
    return response;
}
 
// expiration(정책 유효 기간)을 계산해서 반환하는 함수
// 다음 날을 ISO 형식으로 반환
// https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getDate
function generateExpirationDate() {
    var currentDate = new Date();
    currentDate = currentDate.setDate(currentDate.getDate() + 1);
    //                                ~~~~~~~~~~~~~~~~~~~~~~~~~
    //                                현재 일자 + 1 => 다음 날
    return new Date(currentDate).toISOString();
}
 
// 보안정책문서를 생성
function generatePolicyDocument(filename, next) {
    var expiration = generateExpirationDate();              // 정책 유효기간
    var dir = Math.floor(Math.random()*10**16).toString(16);// 디렉터리 명으로 사용할 난수를 생성
    var key = dir + '/' + filename;                         // 키 이름을 설정
    // https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-HTTPPOSTConstructPolicy.html
    var policy = {
        'expiration': expiration,
        'conditions': [                                 
            { acl: `${C_ACL}` },                     
            { bucket: process.env.UPLOAD_BUCKET },
            [ 'starts-with', '$key', `${dir}/` ],           // 키 이름이 ${dir}/ 형식으로 시작해야 함
            { 'x-amz-algorithm': `${C_X_AMZ_ALGORITHM}`},
            { 'x-amz-credential': `${C_X_AMZ_CREDENTIAL}` },
            { 'x-amz-date': `${C_X_AMZ_DATE}` }
        ]
    };
    next(null, key, policy);                                // waterfall 함수에 따라 encode 함수가 호출
}
 
// 보안정책문서의 포맷을 변경 : 문자열 -> JSON -> 개행문자를 제거 -> BASE64로 인코딩
function encode(key, policy, next) {
    var json = JSON.stringify(policy).replace('\n', '');
    //         ~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~
    //         JSON 형식으로 변환      개행문자를 제거
    var encodedPolicy = new Buffer(json).toString('base64');
    //                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                  BASE64로 인코딩 
    next(null, key, encodedPolicy);                         // waterfall 함수에 따라 sign 함수를 호출
}
 
// 서명 키를 생성
// https://docs.aws.amazon.com/ko_kr/general/latest/gr/signature-v4-examples.html
function getSigningKey() {
    var dateKey              = crypto.HmacSHA256(C_DATE_STAMP  , "AWS4" + process.env.SECRET_ACCESS_KEY);
    var dateRegionKey        = crypto.HmacSHA256(C_REGION_NAME , dateKey);
    var dateRegionServiceKey = crypto.HmacSHA256(C_SERVICE_NAME, dateRegionKey);
    var signingKey           = crypto.HmacSHA256("aws4_request", dateRegionServiceKey);
    return signingKey;
}
 
// 서명을 생성
// https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html
function sign(key, encodedPolicy, next) {
    var signingKey = getSigningKey();
    var signature = crypto.HmacSHA256(encodedPolicy, signingKey);
    next(null, key, encodedPolicy, signature);
}
 
exports.handler = function(event, context, callback) {
    var filename = null;
    if (event.queryStringParameters && event.queryStringParameters.filename) {
        filename = decodeURIComponent(event.queryStringParameters.filename);     
    } else {
        callback(null, createErrorResponse(500, '파일명이 누락되었습니다.'));
        return;
    }
 
    async.waterfall([ async.apply(generatePolicyDocument, filename), encode, sign ], function (err, key, encoded_policy, signature) {
        if (err) {
            callback(null, createErrorResponse(500, err));
        } else {
            var result = {
                upload_url: process.env.UPLOAD_URI,
                encoded_policy: encoded_policy, 
                key: key, 
                acl: `${C_ACL}`,
                x_amz_algorithm: `${C_X_AMZ_ALGORITHM}`, 
                x_amz_credential: `${C_X_AMZ_CREDENTIAL}`, 
                x_amz_date: `${C_X_AMZ_DATE}`,
                x_amz_signature: `${signature}`
            };
            callback(null, createSuccessResponse(result));
        }
    });
}
```

<br>

람다 함수 생성 및 배포

```
PS C:\serverless\get-upload-policy> npm run create
{
    "FunctionName": "get-upload-policy",
    "FunctionArn": "arn:aws:lambda:us-east-1:256193732381:function:get-upload-policy",
    "Runtime": "nodejs12.x",
    "Role": "arn:aws:iam::256193732381:role/lambda-s3-execution-role",
    "Handler": "index.handler",
    "CodeSize": 354467,
    "Description": "",
    "Timeout": 3,
    "MemorySize": 128,
    "LastModified": "2021-03-19T02:34:30.315+0000",
    "CodeSha256": "rLjJSJ+1Mv8Yihw3AYUL3HY4uy8Q3PKEUQ+OfqQpr8E=",
    "Version": "1",
    "TracingConfig": {
        "Mode": "PassThrough"
    },
    "RevisionId": "1b6ad0d4-f309-4945-8b00-78d085f8169c",
    "State": "Active",
    "LastUpdateStatus": "Successful",
    "PackageType": "Zip"
}
```

<br>

콘솔 창으로 람다 함수 확인

![image](https://user-images.githubusercontent.com/77096463/111723718-59a78980-88a7-11eb-8db6-4ec4eea8ed9c.png)

<br>

람다 함수 실행에 필요한 환경 변수 설정

- ACCESS_KEY와 SECRET_ACCESS_KEY : upload-s3 사용자의 액세스키 ID와 비밀 액세스 키를 각각 입력
- UPLOAD_URI :  https://s3.amazonaws.com
- UPLOAD_BUCKET : 업로드 버킷 (serverless-video-upload-haerim)

![image](https://user-images.githubusercontent.com/77096463/111724230-392bff00-88a8-11eb-8422-59bbab043d48.png)

<br>

람다 함수 테스트

- 아래의 코드 작성 후 변경 사항 저장 > 테스트 실행
- 성공 로그 결과 확인

```
{
  "queryStringParameters": {
      "filename" : "myvideo.mp4"
  }
}
```

![image](https://user-images.githubusercontent.com/77096463/111724391-7ee8c780-88a8-11eb-80fe-17e07226b168.png)

<br>